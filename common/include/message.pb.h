// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_message_2eproto 

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_message_2eproto
namespace vanguard {
class ArmMessage;
class ArmMessageDefaultTypeInternal;
extern ArmMessageDefaultTypeInternal _ArmMessage_default_instance_;
class AutoMessage;
class AutoMessageDefaultTypeInternal;
extern AutoMessageDefaultTypeInternal _AutoMessage_default_instance_;
class CamMessage;
class CamMessageDefaultTypeInternal;
extern CamMessageDefaultTypeInternal _CamMessage_default_instance_;
class CanMessage;
class CanMessageDefaultTypeInternal;
extern CanMessageDefaultTypeInternal _CanMessage_default_instance_;
class CommMessage;
class CommMessageDefaultTypeInternal;
extern CommMessageDefaultTypeInternal _CommMessage_default_instance_;
class OdrvMessage;
class OdrvMessageDefaultTypeInternal;
extern OdrvMessageDefaultTypeInternal _OdrvMessage_default_instance_;
class StandardMessage;
class StandardMessageDefaultTypeInternal;
extern StandardMessageDefaultTypeInternal _StandardMessage_default_instance_;
}  // namespace vanguard
namespace google {
namespace protobuf {
template<> ::vanguard::ArmMessage* Arena::CreateMaybeMessage<::vanguard::ArmMessage>(Arena*);
template<> ::vanguard::AutoMessage* Arena::CreateMaybeMessage<::vanguard::AutoMessage>(Arena*);
template<> ::vanguard::CamMessage* Arena::CreateMaybeMessage<::vanguard::CamMessage>(Arena*);
template<> ::vanguard::CanMessage* Arena::CreateMaybeMessage<::vanguard::CanMessage>(Arena*);
template<> ::vanguard::CommMessage* Arena::CreateMaybeMessage<::vanguard::CommMessage>(Arena*);
template<> ::vanguard::OdrvMessage* Arena::CreateMaybeMessage<::vanguard::OdrvMessage>(Arena*);
template<> ::vanguard::StandardMessage* Arena::CreateMaybeMessage<::vanguard::StandardMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace vanguard {

// ===================================================================

class StandardMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vanguard.StandardMessage) */ {
 public:
  StandardMessage();
  virtual ~StandardMessage();

  StandardMessage(const StandardMessage& from);

  inline StandardMessage& operator=(const StandardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StandardMessage(StandardMessage&& from) noexcept
    : StandardMessage() {
    *this = ::std::move(from);
  }

  inline StandardMessage& operator=(StandardMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StandardMessage& default_instance();

  enum MessageCase {
    kComm = 2,
    kCan = 3,
    kArm = 4,
    kOdrv = 5,
    kCam = 6,
    kAuto = 7,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StandardMessage* internal_default_instance() {
    return reinterpret_cast<const StandardMessage*>(
               &_StandardMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(StandardMessage* other);
  friend void swap(StandardMessage& a, StandardMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StandardMessage* New() const final {
    return CreateMaybeMessage<StandardMessage>(NULL);
  }

  StandardMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StandardMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StandardMessage& from);
  void MergeFrom(const StandardMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 dest = 1;
  void clear_dest();
  static const int kDestFieldNumber = 1;
  ::google::protobuf::uint32 dest() const;
  void set_dest(::google::protobuf::uint32 value);

  // .vanguard.CommMessage comm = 2;
  bool has_comm() const;
  void clear_comm();
  static const int kCommFieldNumber = 2;
  private:
  const ::vanguard::CommMessage& _internal_comm() const;
  public:
  const ::vanguard::CommMessage& comm() const;
  ::vanguard::CommMessage* release_comm();
  ::vanguard::CommMessage* mutable_comm();
  void set_allocated_comm(::vanguard::CommMessage* comm);

  // .vanguard.CanMessage can = 3;
  bool has_can() const;
  void clear_can();
  static const int kCanFieldNumber = 3;
  private:
  const ::vanguard::CanMessage& _internal_can() const;
  public:
  const ::vanguard::CanMessage& can() const;
  ::vanguard::CanMessage* release_can();
  ::vanguard::CanMessage* mutable_can();
  void set_allocated_can(::vanguard::CanMessage* can);

  // .vanguard.ArmMessage arm = 4;
  bool has_arm() const;
  void clear_arm();
  static const int kArmFieldNumber = 4;
  private:
  const ::vanguard::ArmMessage& _internal_arm() const;
  public:
  const ::vanguard::ArmMessage& arm() const;
  ::vanguard::ArmMessage* release_arm();
  ::vanguard::ArmMessage* mutable_arm();
  void set_allocated_arm(::vanguard::ArmMessage* arm);

  // .vanguard.OdrvMessage odrv = 5;
  bool has_odrv() const;
  void clear_odrv();
  static const int kOdrvFieldNumber = 5;
  private:
  const ::vanguard::OdrvMessage& _internal_odrv() const;
  public:
  const ::vanguard::OdrvMessage& odrv() const;
  ::vanguard::OdrvMessage* release_odrv();
  ::vanguard::OdrvMessage* mutable_odrv();
  void set_allocated_odrv(::vanguard::OdrvMessage* odrv);

  // .vanguard.CamMessage cam = 6;
  bool has_cam() const;
  void clear_cam();
  static const int kCamFieldNumber = 6;
  private:
  const ::vanguard::CamMessage& _internal_cam() const;
  public:
  const ::vanguard::CamMessage& cam() const;
  ::vanguard::CamMessage* release_cam();
  ::vanguard::CamMessage* mutable_cam();
  void set_allocated_cam(::vanguard::CamMessage* cam);

  // .vanguard.AutoMessage auto = 7;
  bool has_auto_() const;
  void clear_auto_();
  static const int kAutoFieldNumber = 7;
  private:
  const ::vanguard::AutoMessage& _internal_auto_() const;
  public:
  const ::vanguard::AutoMessage& auto_() const;
  ::vanguard::AutoMessage* release_auto_();
  ::vanguard::AutoMessage* mutable_auto_();
  void set_allocated_auto_(::vanguard::AutoMessage* auto_);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:vanguard.StandardMessage)
 private:
  void set_has_comm();
  void set_has_can();
  void set_has_arm();
  void set_has_odrv();
  void set_has_cam();
  void set_has_auto_();

  inline bool has_message() const;
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 dest_;
  union MessageUnion {
    MessageUnion() {}
    ::vanguard::CommMessage* comm_;
    ::vanguard::CanMessage* can_;
    ::vanguard::ArmMessage* arm_;
    ::vanguard::OdrvMessage* odrv_;
    ::vanguard::CamMessage* cam_;
    ::vanguard::AutoMessage* auto__;
  } message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vanguard.CommMessage) */ {
 public:
  CommMessage();
  virtual ~CommMessage();

  CommMessage(const CommMessage& from);

  inline CommMessage& operator=(const CommMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommMessage(CommMessage&& from) noexcept
    : CommMessage() {
    *this = ::std::move(from);
  }

  inline CommMessage& operator=(CommMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommMessage* internal_default_instance() {
    return reinterpret_cast<const CommMessage*>(
               &_CommMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CommMessage* other);
  friend void swap(CommMessage& a, CommMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommMessage* New() const final {
    return CreateMaybeMessage<CommMessage>(NULL);
  }

  CommMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommMessage& from);
  void MergeFrom(const CommMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vanguard.CommMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CanMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vanguard.CanMessage) */ {
 public:
  CanMessage();
  virtual ~CanMessage();

  CanMessage(const CanMessage& from);

  inline CanMessage& operator=(const CanMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CanMessage(CanMessage&& from) noexcept
    : CanMessage() {
    *this = ::std::move(from);
  }

  inline CanMessage& operator=(CanMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CanMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CanMessage* internal_default_instance() {
    return reinterpret_cast<const CanMessage*>(
               &_CanMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CanMessage* other);
  friend void swap(CanMessage& a, CanMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CanMessage* New() const final {
    return CreateMaybeMessage<CanMessage>(NULL);
  }

  CanMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CanMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CanMessage& from);
  void MergeFrom(const CanMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 data = 2;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  ::google::protobuf::uint32 data(int index) const;
  void set_data(int index, ::google::protobuf::uint32 value);
  void add_data(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_data();

  // string hello = 1;
  void clear_hello();
  static const int kHelloFieldNumber = 1;
  const ::std::string& hello() const;
  void set_hello(const ::std::string& value);
  #if LANG_CXX11
  void set_hello(::std::string&& value);
  #endif
  void set_hello(const char* value);
  void set_hello(const char* value, size_t size);
  ::std::string* mutable_hello();
  ::std::string* release_hello();
  void set_allocated_hello(::std::string* hello);

  // @@protoc_insertion_point(class_scope:vanguard.CanMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr hello_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArmMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vanguard.ArmMessage) */ {
 public:
  ArmMessage();
  virtual ~ArmMessage();

  ArmMessage(const ArmMessage& from);

  inline ArmMessage& operator=(const ArmMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArmMessage(ArmMessage&& from) noexcept
    : ArmMessage() {
    *this = ::std::move(from);
  }

  inline ArmMessage& operator=(ArmMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArmMessage* internal_default_instance() {
    return reinterpret_cast<const ArmMessage*>(
               &_ArmMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ArmMessage* other);
  friend void swap(ArmMessage& a, ArmMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArmMessage* New() const final {
    return CreateMaybeMessage<ArmMessage>(NULL);
  }

  ArmMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArmMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArmMessage& from);
  void MergeFrom(const ArmMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArmMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vanguard.ArmMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OdrvMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vanguard.OdrvMessage) */ {
 public:
  OdrvMessage();
  virtual ~OdrvMessage();

  OdrvMessage(const OdrvMessage& from);

  inline OdrvMessage& operator=(const OdrvMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OdrvMessage(OdrvMessage&& from) noexcept
    : OdrvMessage() {
    *this = ::std::move(from);
  }

  inline OdrvMessage& operator=(OdrvMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OdrvMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OdrvMessage* internal_default_instance() {
    return reinterpret_cast<const OdrvMessage*>(
               &_OdrvMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OdrvMessage* other);
  friend void swap(OdrvMessage& a, OdrvMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OdrvMessage* New() const final {
    return CreateMaybeMessage<OdrvMessage>(NULL);
  }

  OdrvMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OdrvMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OdrvMessage& from);
  void MergeFrom(const OdrvMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OdrvMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vanguard.OdrvMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CamMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vanguard.CamMessage) */ {
 public:
  CamMessage();
  virtual ~CamMessage();

  CamMessage(const CamMessage& from);

  inline CamMessage& operator=(const CamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CamMessage(CamMessage&& from) noexcept
    : CamMessage() {
    *this = ::std::move(from);
  }

  inline CamMessage& operator=(CamMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CamMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CamMessage* internal_default_instance() {
    return reinterpret_cast<const CamMessage*>(
               &_CamMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CamMessage* other);
  friend void swap(CamMessage& a, CamMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CamMessage* New() const final {
    return CreateMaybeMessage<CamMessage>(NULL);
  }

  CamMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CamMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CamMessage& from);
  void MergeFrom(const CamMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CamMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vanguard.CamMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AutoMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:vanguard.AutoMessage) */ {
 public:
  AutoMessage();
  virtual ~AutoMessage();

  AutoMessage(const AutoMessage& from);

  inline AutoMessage& operator=(const AutoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AutoMessage(AutoMessage&& from) noexcept
    : AutoMessage() {
    *this = ::std::move(from);
  }

  inline AutoMessage& operator=(AutoMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AutoMessage* internal_default_instance() {
    return reinterpret_cast<const AutoMessage*>(
               &_AutoMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AutoMessage* other);
  friend void swap(AutoMessage& a, AutoMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AutoMessage* New() const final {
    return CreateMaybeMessage<AutoMessage>(NULL);
  }

  AutoMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AutoMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AutoMessage& from);
  void MergeFrom(const AutoMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:vanguard.AutoMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StandardMessage

// uint32 dest = 1;
inline void StandardMessage::clear_dest() {
  dest_ = 0u;
}
inline ::google::protobuf::uint32 StandardMessage::dest() const {
  // @@protoc_insertion_point(field_get:vanguard.StandardMessage.dest)
  return dest_;
}
inline void StandardMessage::set_dest(::google::protobuf::uint32 value) {
  
  dest_ = value;
  // @@protoc_insertion_point(field_set:vanguard.StandardMessage.dest)
}

// .vanguard.CommMessage comm = 2;
inline bool StandardMessage::has_comm() const {
  return message_case() == kComm;
}
inline void StandardMessage::set_has_comm() {
  _oneof_case_[0] = kComm;
}
inline void StandardMessage::clear_comm() {
  if (has_comm()) {
    delete message_.comm_;
    clear_has_message();
  }
}
inline const ::vanguard::CommMessage& StandardMessage::_internal_comm() const {
  return *message_.comm_;
}
inline ::vanguard::CommMessage* StandardMessage::release_comm() {
  // @@protoc_insertion_point(field_release:vanguard.StandardMessage.comm)
  if (has_comm()) {
    clear_has_message();
      ::vanguard::CommMessage* temp = message_.comm_;
    message_.comm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vanguard::CommMessage& StandardMessage::comm() const {
  // @@protoc_insertion_point(field_get:vanguard.StandardMessage.comm)
  return has_comm()
      ? *message_.comm_
      : *reinterpret_cast< ::vanguard::CommMessage*>(&::vanguard::_CommMessage_default_instance_);
}
inline ::vanguard::CommMessage* StandardMessage::mutable_comm() {
  if (!has_comm()) {
    clear_message();
    set_has_comm();
    message_.comm_ = CreateMaybeMessage< ::vanguard::CommMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vanguard.StandardMessage.comm)
  return message_.comm_;
}

// .vanguard.CanMessage can = 3;
inline bool StandardMessage::has_can() const {
  return message_case() == kCan;
}
inline void StandardMessage::set_has_can() {
  _oneof_case_[0] = kCan;
}
inline void StandardMessage::clear_can() {
  if (has_can()) {
    delete message_.can_;
    clear_has_message();
  }
}
inline const ::vanguard::CanMessage& StandardMessage::_internal_can() const {
  return *message_.can_;
}
inline ::vanguard::CanMessage* StandardMessage::release_can() {
  // @@protoc_insertion_point(field_release:vanguard.StandardMessage.can)
  if (has_can()) {
    clear_has_message();
      ::vanguard::CanMessage* temp = message_.can_;
    message_.can_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vanguard::CanMessage& StandardMessage::can() const {
  // @@protoc_insertion_point(field_get:vanguard.StandardMessage.can)
  return has_can()
      ? *message_.can_
      : *reinterpret_cast< ::vanguard::CanMessage*>(&::vanguard::_CanMessage_default_instance_);
}
inline ::vanguard::CanMessage* StandardMessage::mutable_can() {
  if (!has_can()) {
    clear_message();
    set_has_can();
    message_.can_ = CreateMaybeMessage< ::vanguard::CanMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vanguard.StandardMessage.can)
  return message_.can_;
}

// .vanguard.ArmMessage arm = 4;
inline bool StandardMessage::has_arm() const {
  return message_case() == kArm;
}
inline void StandardMessage::set_has_arm() {
  _oneof_case_[0] = kArm;
}
inline void StandardMessage::clear_arm() {
  if (has_arm()) {
    delete message_.arm_;
    clear_has_message();
  }
}
inline const ::vanguard::ArmMessage& StandardMessage::_internal_arm() const {
  return *message_.arm_;
}
inline ::vanguard::ArmMessage* StandardMessage::release_arm() {
  // @@protoc_insertion_point(field_release:vanguard.StandardMessage.arm)
  if (has_arm()) {
    clear_has_message();
      ::vanguard::ArmMessage* temp = message_.arm_;
    message_.arm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vanguard::ArmMessage& StandardMessage::arm() const {
  // @@protoc_insertion_point(field_get:vanguard.StandardMessage.arm)
  return has_arm()
      ? *message_.arm_
      : *reinterpret_cast< ::vanguard::ArmMessage*>(&::vanguard::_ArmMessage_default_instance_);
}
inline ::vanguard::ArmMessage* StandardMessage::mutable_arm() {
  if (!has_arm()) {
    clear_message();
    set_has_arm();
    message_.arm_ = CreateMaybeMessage< ::vanguard::ArmMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vanguard.StandardMessage.arm)
  return message_.arm_;
}

// .vanguard.OdrvMessage odrv = 5;
inline bool StandardMessage::has_odrv() const {
  return message_case() == kOdrv;
}
inline void StandardMessage::set_has_odrv() {
  _oneof_case_[0] = kOdrv;
}
inline void StandardMessage::clear_odrv() {
  if (has_odrv()) {
    delete message_.odrv_;
    clear_has_message();
  }
}
inline const ::vanguard::OdrvMessage& StandardMessage::_internal_odrv() const {
  return *message_.odrv_;
}
inline ::vanguard::OdrvMessage* StandardMessage::release_odrv() {
  // @@protoc_insertion_point(field_release:vanguard.StandardMessage.odrv)
  if (has_odrv()) {
    clear_has_message();
      ::vanguard::OdrvMessage* temp = message_.odrv_;
    message_.odrv_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vanguard::OdrvMessage& StandardMessage::odrv() const {
  // @@protoc_insertion_point(field_get:vanguard.StandardMessage.odrv)
  return has_odrv()
      ? *message_.odrv_
      : *reinterpret_cast< ::vanguard::OdrvMessage*>(&::vanguard::_OdrvMessage_default_instance_);
}
inline ::vanguard::OdrvMessage* StandardMessage::mutable_odrv() {
  if (!has_odrv()) {
    clear_message();
    set_has_odrv();
    message_.odrv_ = CreateMaybeMessage< ::vanguard::OdrvMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vanguard.StandardMessage.odrv)
  return message_.odrv_;
}

// .vanguard.CamMessage cam = 6;
inline bool StandardMessage::has_cam() const {
  return message_case() == kCam;
}
inline void StandardMessage::set_has_cam() {
  _oneof_case_[0] = kCam;
}
inline void StandardMessage::clear_cam() {
  if (has_cam()) {
    delete message_.cam_;
    clear_has_message();
  }
}
inline const ::vanguard::CamMessage& StandardMessage::_internal_cam() const {
  return *message_.cam_;
}
inline ::vanguard::CamMessage* StandardMessage::release_cam() {
  // @@protoc_insertion_point(field_release:vanguard.StandardMessage.cam)
  if (has_cam()) {
    clear_has_message();
      ::vanguard::CamMessage* temp = message_.cam_;
    message_.cam_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vanguard::CamMessage& StandardMessage::cam() const {
  // @@protoc_insertion_point(field_get:vanguard.StandardMessage.cam)
  return has_cam()
      ? *message_.cam_
      : *reinterpret_cast< ::vanguard::CamMessage*>(&::vanguard::_CamMessage_default_instance_);
}
inline ::vanguard::CamMessage* StandardMessage::mutable_cam() {
  if (!has_cam()) {
    clear_message();
    set_has_cam();
    message_.cam_ = CreateMaybeMessage< ::vanguard::CamMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vanguard.StandardMessage.cam)
  return message_.cam_;
}

// .vanguard.AutoMessage auto = 7;
inline bool StandardMessage::has_auto_() const {
  return message_case() == kAuto;
}
inline void StandardMessage::set_has_auto_() {
  _oneof_case_[0] = kAuto;
}
inline void StandardMessage::clear_auto_() {
  if (has_auto_()) {
    delete message_.auto__;
    clear_has_message();
  }
}
inline const ::vanguard::AutoMessage& StandardMessage::_internal_auto_() const {
  return *message_.auto__;
}
inline ::vanguard::AutoMessage* StandardMessage::release_auto_() {
  // @@protoc_insertion_point(field_release:vanguard.StandardMessage.auto)
  if (has_auto_()) {
    clear_has_message();
      ::vanguard::AutoMessage* temp = message_.auto__;
    message_.auto__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::vanguard::AutoMessage& StandardMessage::auto_() const {
  // @@protoc_insertion_point(field_get:vanguard.StandardMessage.auto)
  return has_auto_()
      ? *message_.auto__
      : *reinterpret_cast< ::vanguard::AutoMessage*>(&::vanguard::_AutoMessage_default_instance_);
}
inline ::vanguard::AutoMessage* StandardMessage::mutable_auto_() {
  if (!has_auto_()) {
    clear_message();
    set_has_auto_();
    message_.auto__ = CreateMaybeMessage< ::vanguard::AutoMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:vanguard.StandardMessage.auto)
  return message_.auto__;
}

inline bool StandardMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void StandardMessage::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline StandardMessage::MessageCase StandardMessage::message_case() const {
  return StandardMessage::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommMessage

// -------------------------------------------------------------------

// CanMessage

// string hello = 1;
inline void CanMessage::clear_hello() {
  hello_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CanMessage::hello() const {
  // @@protoc_insertion_point(field_get:vanguard.CanMessage.hello)
  return hello_.GetNoArena();
}
inline void CanMessage::set_hello(const ::std::string& value) {
  
  hello_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vanguard.CanMessage.hello)
}
#if LANG_CXX11
inline void CanMessage::set_hello(::std::string&& value) {
  
  hello_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:vanguard.CanMessage.hello)
}
#endif
inline void CanMessage::set_hello(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hello_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vanguard.CanMessage.hello)
}
inline void CanMessage::set_hello(const char* value, size_t size) {
  
  hello_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vanguard.CanMessage.hello)
}
inline ::std::string* CanMessage::mutable_hello() {
  
  // @@protoc_insertion_point(field_mutable:vanguard.CanMessage.hello)
  return hello_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CanMessage::release_hello() {
  // @@protoc_insertion_point(field_release:vanguard.CanMessage.hello)
  
  return hello_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CanMessage::set_allocated_hello(::std::string* hello) {
  if (hello != NULL) {
    
  } else {
    
  }
  hello_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hello);
  // @@protoc_insertion_point(field_set_allocated:vanguard.CanMessage.hello)
}

// repeated uint32 data = 2;
inline int CanMessage::data_size() const {
  return data_.size();
}
inline void CanMessage::clear_data() {
  data_.Clear();
}
inline ::google::protobuf::uint32 CanMessage::data(int index) const {
  // @@protoc_insertion_point(field_get:vanguard.CanMessage.data)
  return data_.Get(index);
}
inline void CanMessage::set_data(int index, ::google::protobuf::uint32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:vanguard.CanMessage.data)
}
inline void CanMessage::add_data(::google::protobuf::uint32 value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:vanguard.CanMessage.data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CanMessage::data() const {
  // @@protoc_insertion_point(field_list:vanguard.CanMessage.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CanMessage::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:vanguard.CanMessage.data)
  return &data_;
}

// -------------------------------------------------------------------

// ArmMessage

// -------------------------------------------------------------------

// OdrvMessage

// -------------------------------------------------------------------

// CamMessage

// -------------------------------------------------------------------

// AutoMessage

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vanguard

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_message_2eproto
